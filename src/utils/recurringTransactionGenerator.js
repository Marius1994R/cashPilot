// Utility for generating transactions from recurring transactions

export const generateTransactionsFromRecurring = (recurringTransactions, existingTransactions) => {
  const newTransactions = [];
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Get the last 30 days to avoid generating too many past transactions
  const thirtyDaysAgo = new Date(today);
  thirtyDaysAgo.setDate(today.getDate() - 30);

  recurringTransactions.forEach(recurring => {
    if (!recurring.isActive) return;

    const startDate = new Date(recurring.startDate);
    const endDate = recurring.endDate ? new Date(recurring.endDate) : null;

    // Skip if recurring transaction hasn't started yet
    if (startDate > today) return;

    // Skip if recurring transaction has ended
    if (endDate && endDate < today) return;

    // Generate transactions from start date or 30 days ago, whichever is later
    const generationStartDate = new Date(Math.max(startDate.getTime(), thirtyDaysAgo.getTime()));
    
    // Generate all due transactions up to today
    const dueDates = getDueDates(recurring, generationStartDate, today);
    
    dueDates.forEach(dueDate => {
      // Check if transaction already exists for this date and recurring ID
      const existingTransaction = existingTransactions.find(t => 
        t.recurringId === recurring.id && 
        t.date === dueDate.toISOString().split('T')[0]
      );
      
      if (!existingTransaction) {
        newTransactions.push({
          id: `recurring_${recurring.id}_${dueDate.getTime()}`,
          recurringId: recurring.id,
          type: recurring.type,
          amount: recurring.amount,
          description: recurring.description,
          categoryId: recurring.categoryId,
          date: dueDate.toISOString().split('T')[0],
          notes: recurring.notes ? `Auto-generated: ${recurring.notes}` : 'Auto-generated from recurring transaction',
          isAutoGenerated: true
        });
      }
    });
  });

  return newTransactions;
};

const getDueDates = (recurring, startDate, endDate) => {
  const dates = [];
  const current = new Date(startDate);
  
  while (current <= endDate) {
    switch (recurring.frequency) {
      case 'daily':
        dates.push(new Date(current));
        current.setDate(current.getDate() + 1);
        break;
        
      case 'weekly':
        // Find the next occurrence of the specified day of week
        const targetDayOfWeek = recurring.dayOfWeek || startDate.getDay();
        const currentDayOfWeek = current.getDay();
        const daysToAdd = (targetDayOfWeek - currentDayOfWeek + 7) % 7;
        
        if (daysToAdd === 0 && current.getTime() === startDate.getTime()) {
          // If we're starting on the target day, include it
          dates.push(new Date(current));
        }
        
        current.setDate(current.getDate() + (daysToAdd === 0 ? 7 : daysToAdd));
        if (current <= endDate) {
          dates.push(new Date(current));
        }
        
        // Continue weekly from this point
        while (current <= endDate) {
          current.setDate(current.getDate() + 7);
          if (current <= endDate) {
            dates.push(new Date(current));
          }
        }
        break;
        
      case 'monthly':
        const targetDayOfMonth = recurring.dayOfMonth || startDate.getDate();
        
        while (current <= endDate) {
          const monthlyDate = new Date(current.getFullYear(), current.getMonth(), targetDayOfMonth);
          
          // Handle case where target day doesn't exist in the month (e.g., Feb 31)
          if (monthlyDate.getDate() !== parseInt(targetDayOfMonth)) {
            // Go to the last day of the month
            monthlyDate.setDate(0);
          }
          
          if (monthlyDate >= startDate && monthlyDate <= endDate) {
            dates.push(new Date(monthlyDate));
          }
          
          // Move to next month
          current.setMonth(current.getMonth() + 1);
        }
        break;
        
      case 'yearly':
        while (current <= endDate) {
          if (current >= startDate) {
            dates.push(new Date(current));
          }
          current.setFullYear(current.getFullYear() + 1);
        }
        break;
        
      default:
        break;
    }
    
    // Safety check to prevent infinite loops
    if (dates.length > 1000) {
      console.warn('Too many recurring transactions generated, stopping at 1000');
      break;
    }
  }
  
  return dates.sort((a, b) => a.getTime() - b.getTime());
};

export const getNextOccurrence = (recurring) => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const startDate = new Date(recurring.startDate);
  const endDate = recurring.endDate ? new Date(recurring.endDate) : null;
  
  // If recurring transaction has ended, return null
  if (endDate && endDate < today) {
    return null;
  }
  
  // Calculate from today or start date, whichever is later
  const fromDate = startDate > today ? startDate : new Date(today.getTime() + 24 * 60 * 60 * 1000); // tomorrow
  
  const futureDates = getDueDates(recurring, fromDate, new Date(today.getFullYear() + 1, 11, 31));
  
  return futureDates.length > 0 ? futureDates[0].toISOString().split('T')[0] : null;
};

export const shouldGenerateTransactions = (lastGenerationTime) => {
  if (!lastGenerationTime) return true;
  
  const now = new Date();
  const lastGeneration = new Date(lastGenerationTime);
  
  // Generate if it's been more than 1 hour since last generation
  const hoursSinceLastGeneration = (now.getTime() - lastGeneration.getTime()) / (1000 * 60 * 60);
  
  return hoursSinceLastGeneration >= 1;
};